<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>k3.commands API documentation</title>
    <meta name="description" content="This is a small and basic command handling framework for making Python bots." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#k3.commands.logger">logger</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#k3.commands.command">command</a></li>
    <li class="mono"><a href="#k3.commands.convert_arguments">convert_arguments</a></li>
    <li class="mono"><a href="#k3.commands.cooldown">cooldown</a></li>
    <li class="mono"><a href="#k3.commands.parse_arguments">parse_arguments</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#k3.commands.BadArgument">BadArgument</a></span>
        
        </li>
        <li class="mono">
        <span class="class_name"><a href="#k3.commands.Bot">Bot</a></span>
        
          
  <ul>
    <li class="mono"><a href="#k3.commands.Bot.__init__">__init__</a></li>
    <li class="mono"><a href="#k3.commands.Bot.add_command">add_command</a></li>
    <li class="mono"><a href="#k3.commands.Bot.add_module">add_module</a></li>
    <li class="mono"><a href="#k3.commands.Bot.command">command</a></li>
    <li class="mono"><a href="#k3.commands.Bot.invoke">invoke</a></li>
    <li class="mono"><a href="#k3.commands.Bot.load_config">load_config</a></li>
    <li class="mono"><a href="#k3.commands.Bot.logout">logout</a></li>
    <li class="mono"><a href="#k3.commands.Bot.process">process</a></li>
    <li class="mono"><a href="#k3.commands.Bot.regenerate_key">regenerate_key</a></li>
    <li class="mono"><a href="#k3.commands.Bot.remove_command">remove_command</a></li>
    <li class="mono"><a href="#k3.commands.Bot.remove_module">remove_module</a></li>
    <li class="mono"><a href="#k3.commands.Bot.save_config">save_config</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#k3.commands.Command">Command</a></span>
        
          
  <ul>
    <li class="mono"><a href="#k3.commands.Command.__init__">__init__</a></li>
    <li class="mono"><a href="#k3.commands.Command.add_command">add_command</a></li>
    <li class="mono"><a href="#k3.commands.Command.command">command</a></li>
    <li class="mono"><a href="#k3.commands.Command.invoke">invoke</a></li>
    <li class="mono"><a href="#k3.commands.Command.process">process</a></li>
    <li class="mono"><a href="#k3.commands.Command.remove_command">remove_command</a></li>
    <li class="mono"><a href="#k3.commands.Command.set_cooldown">set_cooldown</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#k3.commands.CommandExists">CommandExists</a></span>
        
        </li>
        <li class="mono">
        <span class="class_name"><a href="#k3.commands.CommandGroupMixin">CommandGroupMixin</a></span>
        
          
  <ul>
    <li class="mono"><a href="#k3.commands.CommandGroupMixin.__init__">__init__</a></li>
    <li class="mono"><a href="#k3.commands.CommandGroupMixin.add_command">add_command</a></li>
    <li class="mono"><a href="#k3.commands.CommandGroupMixin.command">command</a></li>
    <li class="mono"><a href="#k3.commands.CommandGroupMixin.invoke">invoke</a></li>
    <li class="mono"><a href="#k3.commands.CommandGroupMixin.process">process</a></li>
    <li class="mono"><a href="#k3.commands.CommandGroupMixin.remove_command">remove_command</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#k3.commands.Context">Context</a></span>
        
          
  <ul>
    <li class="mono"><a href="#k3.commands.Context.__init__">__init__</a></li>
    <li class="mono"><a href="#k3.commands.Context.send">send</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#k3.commands.NotBotOwner">NotBotOwner</a></span>
        
        </li>
        <li class="mono">
        <span class="class_name"><a href="#k3.commands.NotCoroutine">NotCoroutine</a></span>
        
        </li>
        <li class="mono">
        <span class="class_name"><a href="#k3.commands.OnCooldown">OnCooldown</a></span>
        
        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">k3.commands</span> module</h1>
  <p>This is a small and basic command handling framework for making Python bots.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands" class="source">
    <pre><code>#!/usr/bin/env python3

"""This is a small and basic command handling framework for making Python bots."""

import asyncio
import importlib
import inspect
import json
import logging
import shlex
import sys
import time
from typing import List

try:
    import aiohttp
except ImportError:
    pass

import k3.keygen
import k3.formatters.core

logger = logging.getLogger(__name__)


class NotCoroutine(Exception):
    """Raised if a command is passed a function that is not a coroutine."""
    pass


class CommandExists(Exception):
    """Raised if a command registration attempt is made, but the name already exists in the bot."""
    pass


class OnCooldown(Exception):
    """Raised if a command is invoked while on cooldown."""
    pass


class BadArgument(Exception):
    """Raised if a bad argument is supplied to a command."""
    pass


class NotBotOwner(Exception):
    """Raised if an owner-only command is invoked by someone who isn't the bot owner."""
    pass


def parse_arguments(text: str):
    """A very simple argument parser.

    * `text` - An `str` to be parsed into arguments.
    """
    try:
        arguments = shlex.split(text)
    except ValueError:
        # Fallback if shlex blows up.
        text = text.strip()
        arguments = list(filter(lambda item: item != "", text.split(" ")))
    return arguments


def convert_arguments(start: int, signature: inspect.Signature, *args):
    """Parse and typecast arguments based on a function signature. Returns a `list` truncated to
    the length of the signature or the argument list, whichever is shorter.

    * `start` - The starting index to use for the parameters. This is used so we can skip over the
                `ctx` argument that is required by k3 command coroutines.
    * `signature` - An `inspect.Signature` that is used as a basis for converting the arguments.
    * `args` - The arguments to be converted.
    """
    return_args = []
    signature_params = list(signature.parameters.values())
    for index, (param, arg) in enumerate(zip(signature_params[start:], args)):
        if param.kind == param.VAR_POSITIONAL:
            # We've reached an *args parameter, so we just concatenate the remaining arguments
            # onto the return. This is why enumerate is used here - it gives us an index to mark
            # where the leftover arguments begin.
            return_args += args[index:]
        elif param.annotation is not param.empty:
            try:
                return_args.append(param.annotation(arg))  # Typecast using param.annotation.
            except ValueError:
                raise BadArgument((f"Argument named \"{param.name}\" must be of type "
                                   f"{param.annotation.__name__}."))
        else:
            return_args.append(arg)
    return return_args


class Context:
    """This object represents an abstracted context under which a `Command` is invoked.

    You don't make these manually.
    """

    def __init__(self, *, callback_send, character_limit: int=2000, command, bot,
                 invoked_with: str):
        """**Parameters**

        * `callback_send` - A coroutine for sending a message. This is entirely dependent on your
                            library. You may have to implement a custom coroutine, depending on
                            the format of your library's own method for sending messages.
        * `character_limit` - An `int` representing the maximum allowable characters per message.
                              The abstracted `send` method will automatically split messages that
                              are too long; if this behavior is undesirable, you should do a
                              manual truncation.
        * `command` - The `Command` object associated with the context.
        * `bot` - The `Bot` object associated with your bot.
        * `invoked_with` - `str` representing the command name associated with the context.
        * `formatter` or `f` - Shorthand for `ctx.bot.formatter`.
        """
        if not asyncio.iscoroutinefunction(callback_send):
            raise NotCoroutine(f"{callback_send.__name__} is not a coroutine function.")
        self._callback_send = callback_send
        self.bot = bot
        self.command = command
        self.character_limit = character_limit
        self.invoked_with = invoked_with

    @property
    def formatter(self):
        """Shorthand for `ctx.bot.formatter`."""
        return self.bot.formatter

    @property
    def f(self):
        """Shorthand for `ctx.bot.formatter`."""
        return self.bot.formatter

    async def send(self, message):
        """An abstracted method that sends a message to the desired location. This is a coroutine.

        You must specify the actual send method in the `Context` constructor.
        """
        message = str(message)
        cl = self.character_limit
        pages = [message[i:i+cl] for i in range(0, len(message), cl)]
        for page in pages:
            await self._callback_send(page)


class CommandGroupMixin:
    """This class contains partial command handling facilities, as well as command grouping
    functionality. Generally, you do not use this by itself.

    Both `Bot` and `Command` inherit from this class.

    * `commands` - A `dict` containing all of the bot's commands.
    * `all_commands` - A `dict` containing all of the bot's commands, counting aliases.
    * `name` - An `str` representing the name of the `CommandGroupMixin`. Children classes
               should reimplement `__init__` to set it as desired. `name` is used in `process`
               to detect command invocations, where a matching `name` will trigger the
               corresponding command.
    * `aliases` - A `list` of `str` representing alternates to `name` for command invocations.
    * `parent` - The parent object of the mixin; the command or bot that it has been added to.
    """

    def __init__(self, *, name: str=None, aliases: List[str]=[]):
        self.commands = {}
        self.all_commands = {}
        self.name = name or self.__name__
        self.aliases = []
        self.parent = None

    def add_command(self, command, *, skip_duplicate=False):
        """Add a `Command` object to the group.

        Normally, you do not call this by itself; instead, you use the `CommandGroupMixin.command`
        decorator. Or you may call `Bot.add_module()` on a module that contains a series of commands
        created using the `k3.command` decorator.

        * `command` - A `Command` object to be added.
        * `skip_duplicate` - A `bool`. If `True`, the function returns immediately if the command
                             is found to already exist. Otherwise, it raises a `CommandExists`
                             exception. Defaults to `False`.
        """
        if command.name in self.all_commands.keys() and skip_duplicate:
            return
        elif command.name in self.all_commands.keys():
            raise CommandExists(f"{command.name} is a command that already exists.")
        command.parent = self  # Set the command's bot instance
        self.commands[command.name] = command
        self.all_commands[command.name] = command
        for alias in command.aliases:
            self.all_commands[alias] = command

    def remove_command(self, name):
        """Remove a `Command` object from the group, by name.

        * `name` - An `str` referring to the name of the command to remove.
        """
        aliases = self.commands[name].aliases
        self.commands[name].parent = None
        del self.commands[name]
        del self.all_commands[name]
        for alias in aliases:
            del self.all_commands[alias]

    async def process(self, message: str, *, callback_send, is_owner: bool=False,
                      character_limit: int=2000, prefixes: List[str]=[]):
        """Process the given message. This is a coroutine.

        * `message` - A message `str` for the bot to process.
        * `is_owner` - A `bool` used to force an owner check override if you want an alternative
                       handler instead of k3's clunky key system. This is useful if the library you
                       use has some automated means of distinguishing the bot owner. For example,
                       discord.py offers owner information via `discord.Client.application_info()`,
                       so you can use that to check if the message sender is the owner, and then
                       pass the result on to the k3 handler.
        * `callback_send` - A coroutine that k3 will use to send messages. This is library-
                            dependent, and you may have to define a custom coroutine depending on
                            the exact format of your library's methods.
        * `character_limit` - An `int` representing the number of allowed characters in a given
                              message.
        * `prefixes` - A `list` of `str` to look out for in the process of invoking commands.
                       If a message starts with one of the `str` in the `list`, then an
                       invocation will be attempted. Normally, you don't override this.
        """
        if not prefixes:
            prefixes = [self.name] + self.aliases

        for prefix in prefixes:
            if message.startswith(prefix):

                noprefix_message = message[len(prefix):].strip()
                arguments = noprefix_message.split(" ")

                if arguments and arguments[0] in self.all_commands.keys():
                    await self.all_commands[arguments[0]].process(noprefix_message,
                                                                  is_owner=is_owner,
                                                                  callback_send=callback_send,
                                                                  character_limit=character_limit)
                else:
                    await self.invoke(message, is_owner=is_owner, callback_send=callback_send,
                                      character_limit=character_limit)
                break

    async def invoke(self, message: str, *, is_owner: bool=False, callback_send,
                     character_limit: int=2000):
        """This is a dummy `invoke` method, to be reimplemented in children classes.

        It is called to invoke the `CommandGroupMixin`, but this is a mixin class and thus does
        not have anything to invoke, really.
        """
        pass

    def command(self, *, name: str=None, aliases: List[str]=[], help: str=None,
                owner_only: bool=False):
        """This is a shortcut decorator that directly adds a subcommand.

        Refer to the `k3.command` decorator for more details, as it is functionally similar.
        """

        def decorator(coro):
            new_command = Command(coro, name=name, aliases=aliases, help=help,
                                  owner_only=owner_only)
            self.add_command(new_command)
            return new_command

        return decorator

    @property
    def top_level(self):
        """Returns the top-level container for this object. Usually a commands.Bot()."""
        current_level = self
        while current_level.parent:
            current_level = current_level.parent
        return current_level


class Bot(CommandGroupMixin):
    """This is a bot object that contains basic command handling functionality.

    Inherits `CommandGroupMixin` functionality; refer to that class for additional functionality.
    """

    def __init__(self, *, loop: asyncio.AbstractEventLoop, prefix: str, name: str="k3",
                 description: str="A bot made using the k3 command handler.", logout=None,
                 formatter=None, config_file: str="config.json"):
        """This object respresents a command-based bot; i.e. it can process and handle commands.
        Commands are represented by `Command` objects.

        To use this, instantiate it and then call `Bot.process(text)` whenever a message event
        occurs. Some examples are provided in the repository.

        * `loop` - An `asyncio.AbstractEventLoop` to pass to the bot.
        * `prefix` - An `str` that the bot uses to identify whether a command is being
                     requested by someone. All attempted command invocations must start with
                     the prefix.
        * `name` - An `str` representing the name of the bot. Defaults to `k3`.
        * `description` - An `str` representing the description of the bot. Defaults to `A bot made
                          using the k3 command handler.`
        * `logout` - An optional callable parameter that allows for an abstracted bot logout. This
                     allows you to supply a method for cleanly exiting the bot. It can be as simple
                     as supplying `sys.exit`, though this will usually not be a clean exit. The
                     `logout` parameter may be a coroutine function.
        * `formatter` - A custom `Formatter` object for formatting things into platform-specific
                        outputs. You can use one of k3's built-in formatters, or you can make one
                        of your own. Formatters should be subclassed from
                        `k3.formatters.BaseFormatter`.
        * `config_file` - An `str` representing the configuration file of the bot. Defaults to
                          `config.json`. This doesn't really have to be used, but it's there for
                          convenience reasons.

        Instance variables not in the constructor:

        * `key` - An `str` key for the bot owner. Use this for platform-agnostic owner-only
                  commands. Commands marked as owner-only will require the key to be supplied as
                  the last command argument. Because the key obviously becomes public as soon as
                  it's posted to a chat, it changes upon every use.
        * `session` - An `aiohttp.ClientSession` that the bot can use to make HTTP requests.
                      This is useful for commands that perform API hooks. If `aiohttp` is not
                      available, this is just `None`.
        * `config` - A `dict` containing key-value pairs meant for bot configuration. This doesn't
                     really have to be used, but it's there for convenience reasons.

        Example usage:

            import discord

            from k3 import commands

            client = discord.Client()
            bot = commands.Bot(loop=client.loop, prefix=">>", name="MyBot", logout=client.logout)
        """
        super(Bot, self).__init__(name=name)
        self.loop = loop
        try:
            self.session = aiohttp.ClientSession(loop=self.loop)
        except NameError:
            self.session = None
        self.prefix = prefix
        self.description = description
        self._logout = logout
        if not formatter:
            self.formatter = k3.formatters.core.BaseFormatter()
        elif not isinstance(formatter, k3.formatters.core.BaseFormatter):
            raise TypeError(f"{formatter} is not a BaseFormatter.")
        else:
            self.formatter = formatter
        self.config = {}
        self.config_file = config_file

        self._task_key_regeneration = self.loop.create_task(self._regenerate_key_auto())

    async def logout(self):
        """An abstracted logout method. This is a coroutine.

        You must specify the logout function in the `Bot` constructor.
        """
        self.session.close()
        self._task_key_regeneration.cancel()
        if asyncio.iscoroutinefunction(self._logout):
            await self._logout()
        elif callable(self._logout):
            self._logout()

    def load_config(self, filename: str=None):
        """Load config from a JSON file.

        * `filename` - The filename of the JSON file to be loaded. If not specified, the bot will
                       default to `Bot.config_file`.
        """
        if not filename:
            filename = self.config_file
        with open(filename) as file_object:
            config = json.load(file_object)
        if isinstance(config, dict):
            for key, value in config.items():
                self.config[key] = value

    def save_config(self, filename: str=None):
        """Save config to a JSON file.

        * `filename` - The filename of the JSON file to be saved to. If not specified, the bot will
                       default to `Bot.config_file`.
        """
        if not filename:
            filename = self.config_file
        with open(filename, "w") as file_object:
            json.dump(self.config, file_object)

    def regenerate_key(self):
        """Generate a new key for the bot. Random alphanumeric string, 64 characters long.

        This is called every 30 minutes, and also whenever an owner-only command is invoked unless
        an override is requested.
        """
        self.key = k3.keygen.generate_key()
        logger.info("Bot key is now {self.key}")

    async def _regenerate_key_auto(self):
        """Regenerate key every 30 minutes."""
        while 1:
            self.regenerate_key()
            await asyncio.sleep(1800)

    async def process(self, message: str, *, callback_send, is_owner: bool=False,
                      character_limit: int=2000):
        """Reimplemented `process` to check against the bot's prefix. Refer to
        `CommandGroupMixin.process` for more details."""
        await super(Bot, self).process(message, callback_send=callback_send, is_owner=is_owner,
                                       character_limit=character_limit, prefixes=[self.prefix])

    def add_module(self, name: str, *, skip_duplicate_commands: bool=False):
        """Add a Python module to the bot, by name.

        The bot will check said module for instances of `Command` and add all of them to itself.

        * `name` - An `str` representing the name of the module to import.
        * `skip_duplicate_commands` - A `bool`. If `True`, the function will skip command names
                                      that already exist. Otherwise, it raises a `CommandExists`
                                      exception. Defaults to `False`.
        """

        # If the module is already in memory, we reload it instead.
        if name in sys.modules.keys():
            importlib.reload(sys.modules[name])
            module = sys.modules[name]
        else:
            module = importlib.import_module(name)

        for command in dir(module):

            command = getattr(module, command)

            if isinstance(command, Command) and not command.parent:
                self.add_command(command, skip_duplicate=skip_duplicate_commands)

    def remove_module(self, name):
        """Remove a Python module to the bot, by name.

        When this is called, the bot will remove all `Command` objects that belong to the module
        in question. It does not unload the module from memory, as Python doesn't support this.
        This isn't considered a serious issue, since the hit to memory usage shouldn't be
        significant.

        * `name` - An `str` representing the name of the module to remove.
        """
        for command_name, command in tuple(self.commands.items()):
            if command.coro.__module__ == name:
                self.remove_command(command_name)


class Command(CommandGroupMixin):

    def __init__(self, coro, *, name: str=None, aliases: List[str]=[], help: str=None,
                 owner_only=False):
        """This object represents a command that a bot can use.

        Normally, you do not construct this directly. Use the decorator syntax instead.

        * `coro` - A coroutine function that the command uses upon calling `invoke()`.
                   Should have an `*args` to catch any extra arguments.
        * `name` - An `str` representing the name for the command. If unspecified, it's set to
                   `coro.__name__`.
        * `aliases` - A `list` of `str` representing aliases for the command; that is, alternative
                      names you can invoke the command under.
        * `help` - An `str` representing the command's help text. It can alternatively be read from
                   the coroutine's docstring, which makes code easier to read.
        * `owner_only` - A `bool`. Determines whether the command is meant for the bot owner only.
                         If `True`, the command will require the bot's temporary key as the final
                         command argument, and will fail to run unless `is_owner` is overridden in
                         the call to the `invoke()` method. Defaults to `False`.

        Instance variables not in the constructor:

        * `bot` - The `Bot` instance that the command is assigned to.
        * `signature` - An `inspect.Signature` reflecting the command signature.
        """

        name = name or coro.__name__
        super(Command, self).__init__(name=name, aliases=aliases)

        self.help = help or inspect.getdoc(coro)

        if not asyncio.iscoroutinefunction(coro):
            raise NotCoroutine(f"{coro.__name__} is not a coroutine function.")
        self.coro = coro
        self.signature = inspect.signature(self.coro)

        self.owner_only = owner_only

        # These are used internally for cooldowns.
        self._interval_start = 0  # This tracks the start of an interval.
        self._times_invoked = 0  # This tracks the number of times the command is used.
        self._limit = 0  # Limit of uses per interval
        self._interval = 0  # Interval in seconds

    def set_cooldown(self, limit: int, interval: float=1):
        """This sets the cooldown for the command.

        Normally, you do not call this directly; use the decorator syntax instead.

        * `limit` - An `int` representing the limit of uses per interval before the cooldown kicks.
        * `interval` - A `float` representing, in seconds, the interval before the cooldown resets.
                       Defaults to `1`.
        """
        self._limit = limit
        self._interval = interval

    def _update_cooldown(self):
        if self._limit > 1:
            invoke_time = time.time()
            if invoke_time - self._interval_start >= self._interval:
                self._times_invoked = 1
                self._interval_start = invoke_time
            elif self._times_invoked >= self._limit:
                raise OnCooldown("Command on cooldown.")
            else:
                self._times_invoked += 1

    async def invoke(self, message: str, *, is_owner: bool=False, callback_send,
                     character_limit: int=2000):
        """Calling this will invoke the command, provided a message string.

        Normally, you do not call this by itself; instead run `Bot.process()`.

        * `message` - An `str` to pass the command for processing.
        * `is_owner` - A `bool` that overrides the owner checking. Use this if you have some other
                       means of checking for the owner.
        * `callback_send` - A coroutine that k3 will use to send messages. This is library-
                            dependent, and you may have to define a custom coroutine depending on
                            the exact format of your library's methods.
        * `character_limit` - An `int` representing the number of allowed characters in a given
                              message.
        """
        # Cooldown
        self._update_cooldown()

        arguments = parse_arguments(message)
        invoked_with = arguments.pop(0)

        # Override.
        if is_owner:
            pass
        # Check arguments against the bot's key if owner_only.
        # We assume that top_level is a Bot in this case.
        elif self.owner_only and (not arguments or arguments[-1] != self.top_level.key):
            raise NotBotOwner("You don't own this bot.")
        elif self.owner_only:
            arguments.pop(-1)
            self.top_level.regenerate_key()

        ctx = Context(callback_send=callback_send, bot=self.top_level, command=self,
                      character_limit=character_limit, invoked_with=invoked_with)
        converted_arguments = convert_arguments(1, self.signature, *arguments)
        response = await self.coro(ctx, *converted_arguments)

        return response


def command(*, name: str=None, aliases: List[str]=[], help: str=None, owner_only: bool=False):
    """This is a decorator, which you call on a coroutine to make it into a `Command` object.

    Normally, you should use this instead of constructing `Command` objects directly.

    * `coro` - A coroutine function that the command uses upon calling `invoke()`.
               Should have an `*args` to catch any extra arguments.
    * `name` - An `str` reperesnting the name for the command. If unspecified, it's set to
               `coro.__name__`.
    * `aliases` - A `list` of `str` representing aliases for the command; that is, alternative
                  names you can invoke the command under.
    * `help` - An `str` representing the command's help text.
    * `owner_only` - A `bool`. Determines whether the command is meant for the bot owner only.
                     If `True`, the command will require the bot's temporary key as the final
                     command argument, and will fail to run unless `is_owner` is overridden in the
                     call to the `invoke()` method. Defaults to `False`.

    Example:

        @commands.command()
        async def ping(*args):
            return "Pong!"
    """

    def decorator(coro):
        new_command = Command(coro, name=name, aliases=aliases, help=help, owner_only=owner_only)
        return new_command

    return decorator


def cooldown(uses: int, interval: float=1):
    """This is a decorator that sets the cooldown for a command.

    Normally, you should use this instead of calling `Command.set_cooldown()` directly.

    * `limit` - An `int` representing the limit of uses per interval before the cooldown kicks.
    * `interval` - A `float` representing, in seconds, the interval before the cooldown resets.
                   Defaults to `1`.

    Example:

        @commands.cooldown(6, 12) # Allow 6 uses per 12 seconds.
        @commands.command()
        async def ping(*args):
            return "Pong!"
    """

    def decorator(command):
        command.set_cooldown(uses, interval)
        return command

    return decorator
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="k3.commands.logger" class="name">var <span class="ident">logger</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="k3.commands.command">
    <p>def <span class="ident">command</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>This is a decorator, which you call on a coroutine to make it into a <code>Command</code> object.</p>
<p>Normally, you should use this instead of constructing <code>Command</code> objects directly.</p>
<ul>
<li><code>coro</code> - A coroutine function that the command uses upon calling <code>invoke()</code>.
           Should have an <code>*args</code> to catch any extra arguments.</li>
<li><code>name</code> - An <code>str</code> reperesnting the name for the command. If unspecified, it's set to
           <code>coro.__name__</code>.</li>
<li><code>aliases</code> - A <code>list</code> of <code>str</code> representing aliases for the command; that is, alternative
              names you can invoke the command under.</li>
<li><code>help</code> - An <code>str</code> representing the command's help text.</li>
<li><code>owner_only</code> - A <code>bool</code>. Determines whether the command is meant for the bot owner only.
                 If <code>True</code>, the command will require the bot's temporary key as the final
                 command argument, and will fail to run unless <code>is_owner</code> is overridden in the
                 call to the <code>invoke()</code> method. Defaults to <code>False</code>.</li>
</ul>
<p>Example:</p>
<pre><code>@commands.command()
async def ping(*args):
    return "Pong!"
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.command', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.command" class="source">
    <pre><code>def command(*, name: str=None, aliases: List[str]=[], help: str=None, owner_only: bool=False):
    """This is a decorator, which you call on a coroutine to make it into a `Command` object.

    Normally, you should use this instead of constructing `Command` objects directly.

    * `coro` - A coroutine function that the command uses upon calling `invoke()`.
               Should have an `*args` to catch any extra arguments.
    * `name` - An `str` reperesnting the name for the command. If unspecified, it's set to
               `coro.__name__`.
    * `aliases` - A `list` of `str` representing aliases for the command; that is, alternative
                  names you can invoke the command under.
    * `help` - An `str` representing the command's help text.
    * `owner_only` - A `bool`. Determines whether the command is meant for the bot owner only.
                     If `True`, the command will require the bot's temporary key as the final
                     command argument, and will fail to run unless `is_owner` is overridden in the
                     call to the `invoke()` method. Defaults to `False`.

    Example:

        @commands.command()
        async def ping(*args):
            return "Pong!"
    """

    def decorator(coro):
        new_command = Command(coro, name=name, aliases=aliases, help=help, owner_only=owner_only)
        return new_command

    return decorator
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="k3.commands.convert_arguments">
    <p>def <span class="ident">convert_arguments</span>(</p><p>start, signature, *args)</p>
    </div>
    

    
  
    <div class="desc"><p>Parse and typecast arguments based on a function signature. Returns a <code>list</code> truncated to
the length of the signature or the argument list, whichever is shorter.</p>
<ul>
<li><code>start</code> - The starting index to use for the parameters. This is used so we can skip over the
            <code>ctx</code> argument that is required by k3 command coroutines.</li>
<li><code>signature</code> - An <code>inspect.Signature</code> that is used as a basis for converting the arguments.</li>
<li><code>args</code> - The arguments to be converted.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.convert_arguments', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.convert_arguments" class="source">
    <pre><code>def convert_arguments(start: int, signature: inspect.Signature, *args):
    """Parse and typecast arguments based on a function signature. Returns a `list` truncated to
    the length of the signature or the argument list, whichever is shorter.

    * `start` - The starting index to use for the parameters. This is used so we can skip over the
                `ctx` argument that is required by k3 command coroutines.
    * `signature` - An `inspect.Signature` that is used as a basis for converting the arguments.
    * `args` - The arguments to be converted.
    """
    return_args = []
    signature_params = list(signature.parameters.values())
    for index, (param, arg) in enumerate(zip(signature_params[start:], args)):
        if param.kind == param.VAR_POSITIONAL:
            # We've reached an *args parameter, so we just concatenate the remaining arguments
            # onto the return. This is why enumerate is used here - it gives us an index to mark
            # where the leftover arguments begin.
            return_args += args[index:]
        elif param.annotation is not param.empty:
            try:
                return_args.append(param.annotation(arg))  # Typecast using param.annotation.
            except ValueError:
                raise BadArgument((f"Argument named \"{param.name}\" must be of type "
                                   f"{param.annotation.__name__}."))
        else:
            return_args.append(arg)
    return return_args
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="k3.commands.cooldown">
    <p>def <span class="ident">cooldown</span>(</p><p>uses, interval=1)</p>
    </div>
    

    
  
    <div class="desc"><p>This is a decorator that sets the cooldown for a command.</p>
<p>Normally, you should use this instead of calling <code>Command.set_cooldown()</code> directly.</p>
<ul>
<li><code>limit</code> - An <code>int</code> representing the limit of uses per interval before the cooldown kicks.</li>
<li><code>interval</code> - A <code>float</code> representing, in seconds, the interval before the cooldown resets.
               Defaults to <code>1</code>.</li>
</ul>
<p>Example:</p>
<pre><code>@commands.cooldown(6, 12) # Allow 6 uses per 12 seconds.
@commands.command()
async def ping(*args):
    return "Pong!"
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.cooldown', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.cooldown" class="source">
    <pre><code>def cooldown(uses: int, interval: float=1):
    """This is a decorator that sets the cooldown for a command.

    Normally, you should use this instead of calling `Command.set_cooldown()` directly.

    * `limit` - An `int` representing the limit of uses per interval before the cooldown kicks.
    * `interval` - A `float` representing, in seconds, the interval before the cooldown resets.
                   Defaults to `1`.

    Example:

        @commands.cooldown(6, 12) # Allow 6 uses per 12 seconds.
        @commands.command()
        async def ping(*args):
            return "Pong!"
    """

    def decorator(command):
        command.set_cooldown(uses, interval)
        return command

    return decorator
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="k3.commands.parse_arguments">
    <p>def <span class="ident">parse_arguments</span>(</p><p>text)</p>
    </div>
    

    
  
    <div class="desc"><p>A very simple argument parser.</p>
<ul>
<li><code>text</code> - An <code>str</code> to be parsed into arguments.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.parse_arguments', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.parse_arguments" class="source">
    <pre><code>def parse_arguments(text: str):
    """A very simple argument parser.

    * `text` - An `str` to be parsed into arguments.
    """
    try:
        arguments = shlex.split(text)
    except ValueError:
        # Fallback if shlex blows up.
        text = text.strip()
        arguments = list(filter(lambda item: item != "", text.split(" ")))
    return arguments
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="k3.commands.BadArgument" class="name">class <span class="ident">BadArgument</span></p>
      
  
    <div class="desc"><p>Raised if a bad argument is supplied to a command.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.BadArgument', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.BadArgument" class="source">
    <pre><code>class BadArgument(Exception):
    """Raised if a bad argument is supplied to a command."""
    pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#k3.commands.BadArgument">BadArgument</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="k3.commands.BadArgument.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="k3.commands.Bot" class="name">class <span class="ident">Bot</span></p>
      
  
    <div class="desc"><p>This is a bot object that contains basic command handling functionality.</p>
<p>Inherits <code>CommandGroupMixin</code> functionality; refer to that class for additional functionality.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Bot', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Bot" class="source">
    <pre><code>class Bot(CommandGroupMixin):
    """This is a bot object that contains basic command handling functionality.

    Inherits `CommandGroupMixin` functionality; refer to that class for additional functionality.
    """

    def __init__(self, *, loop: asyncio.AbstractEventLoop, prefix: str, name: str="k3",
                 description: str="A bot made using the k3 command handler.", logout=None,
                 formatter=None, config_file: str="config.json"):
        """This object respresents a command-based bot; i.e. it can process and handle commands.
        Commands are represented by `Command` objects.

        To use this, instantiate it and then call `Bot.process(text)` whenever a message event
        occurs. Some examples are provided in the repository.

        * `loop` - An `asyncio.AbstractEventLoop` to pass to the bot.
        * `prefix` - An `str` that the bot uses to identify whether a command is being
                     requested by someone. All attempted command invocations must start with
                     the prefix.
        * `name` - An `str` representing the name of the bot. Defaults to `k3`.
        * `description` - An `str` representing the description of the bot. Defaults to `A bot made
                          using the k3 command handler.`
        * `logout` - An optional callable parameter that allows for an abstracted bot logout. This
                     allows you to supply a method for cleanly exiting the bot. It can be as simple
                     as supplying `sys.exit`, though this will usually not be a clean exit. The
                     `logout` parameter may be a coroutine function.
        * `formatter` - A custom `Formatter` object for formatting things into platform-specific
                        outputs. You can use one of k3's built-in formatters, or you can make one
                        of your own. Formatters should be subclassed from
                        `k3.formatters.BaseFormatter`.
        * `config_file` - An `str` representing the configuration file of the bot. Defaults to
                          `config.json`. This doesn't really have to be used, but it's there for
                          convenience reasons.

        Instance variables not in the constructor:

        * `key` - An `str` key for the bot owner. Use this for platform-agnostic owner-only
                  commands. Commands marked as owner-only will require the key to be supplied as
                  the last command argument. Because the key obviously becomes public as soon as
                  it's posted to a chat, it changes upon every use.
        * `session` - An `aiohttp.ClientSession` that the bot can use to make HTTP requests.
                      This is useful for commands that perform API hooks. If `aiohttp` is not
                      available, this is just `None`.
        * `config` - A `dict` containing key-value pairs meant for bot configuration. This doesn't
                     really have to be used, but it's there for convenience reasons.

        Example usage:

            import discord

            from k3 import commands

            client = discord.Client()
            bot = commands.Bot(loop=client.loop, prefix=">>", name="MyBot", logout=client.logout)
        """
        super(Bot, self).__init__(name=name)
        self.loop = loop
        try:
            self.session = aiohttp.ClientSession(loop=self.loop)
        except NameError:
            self.session = None
        self.prefix = prefix
        self.description = description
        self._logout = logout
        if not formatter:
            self.formatter = k3.formatters.core.BaseFormatter()
        elif not isinstance(formatter, k3.formatters.core.BaseFormatter):
            raise TypeError(f"{formatter} is not a BaseFormatter.")
        else:
            self.formatter = formatter
        self.config = {}
        self.config_file = config_file

        self._task_key_regeneration = self.loop.create_task(self._regenerate_key_auto())

    async def logout(self):
        """An abstracted logout method. This is a coroutine.

        You must specify the logout function in the `Bot` constructor.
        """
        self.session.close()
        self._task_key_regeneration.cancel()
        if asyncio.iscoroutinefunction(self._logout):
            await self._logout()
        elif callable(self._logout):
            self._logout()

    def load_config(self, filename: str=None):
        """Load config from a JSON file.

        * `filename` - The filename of the JSON file to be loaded. If not specified, the bot will
                       default to `Bot.config_file`.
        """
        if not filename:
            filename = self.config_file
        with open(filename) as file_object:
            config = json.load(file_object)
        if isinstance(config, dict):
            for key, value in config.items():
                self.config[key] = value

    def save_config(self, filename: str=None):
        """Save config to a JSON file.

        * `filename` - The filename of the JSON file to be saved to. If not specified, the bot will
                       default to `Bot.config_file`.
        """
        if not filename:
            filename = self.config_file
        with open(filename, "w") as file_object:
            json.dump(self.config, file_object)

    def regenerate_key(self):
        """Generate a new key for the bot. Random alphanumeric string, 64 characters long.

        This is called every 30 minutes, and also whenever an owner-only command is invoked unless
        an override is requested.
        """
        self.key = k3.keygen.generate_key()
        logger.info("Bot key is now {self.key}")

    async def _regenerate_key_auto(self):
        """Regenerate key every 30 minutes."""
        while 1:
            self.regenerate_key()
            await asyncio.sleep(1800)

    async def process(self, message: str, *, callback_send, is_owner: bool=False,
                      character_limit: int=2000):
        """Reimplemented `process` to check against the bot's prefix. Refer to
        `CommandGroupMixin.process` for more details."""
        await super(Bot, self).process(message, callback_send=callback_send, is_owner=is_owner,
                                       character_limit=character_limit, prefixes=[self.prefix])

    def add_module(self, name: str, *, skip_duplicate_commands: bool=False):
        """Add a Python module to the bot, by name.

        The bot will check said module for instances of `Command` and add all of them to itself.

        * `name` - An `str` representing the name of the module to import.
        * `skip_duplicate_commands` - A `bool`. If `True`, the function will skip command names
                                      that already exist. Otherwise, it raises a `CommandExists`
                                      exception. Defaults to `False`.
        """

        # If the module is already in memory, we reload it instead.
        if name in sys.modules.keys():
            importlib.reload(sys.modules[name])
            module = sys.modules[name]
        else:
            module = importlib.import_module(name)

        for command in dir(module):

            command = getattr(module, command)

            if isinstance(command, Command) and not command.parent:
                self.add_command(command, skip_duplicate=skip_duplicate_commands)

    def remove_module(self, name):
        """Remove a Python module to the bot, by name.

        When this is called, the bot will remove all `Command` objects that belong to the module
        in question. It does not unload the module from memory, as Python doesn't support this.
        This isn't considered a serious issue, since the hit to memory usage shouldn't be
        significant.

        * `name` - An `str` representing the name of the module to remove.
        """
        for command_name, command in tuple(self.commands.items()):
            if command.coro.__module__ == name:
                self.remove_command(command_name)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#k3.commands.Bot">Bot</a></li>
          <li><a href="#k3.commands.CommandGroupMixin">CommandGroupMixin</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="k3.commands.Bot.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>This object respresents a command-based bot; i.e. it can process and handle commands.
Commands are represented by <code>Command</code> objects.</p>
<p>To use this, instantiate it and then call <code>Bot.process(text)</code> whenever a message event
occurs. Some examples are provided in the repository.</p>
<ul>
<li><code>loop</code> - An <code>asyncio.AbstractEventLoop</code> to pass to the bot.</li>
<li><code>prefix</code> - An <code>str</code> that the bot uses to identify whether a command is being
             requested by someone. All attempted command invocations must start with
             the prefix.</li>
<li><code>name</code> - An <code>str</code> representing the name of the bot. Defaults to <code>k3</code>.</li>
<li><code>description</code> - An <code>str</code> representing the description of the bot. Defaults to <code>A bot made
                  using the k3 command handler.</code></li>
<li><code>logout</code> - An optional callable parameter that allows for an abstracted bot logout. This
             allows you to supply a method for cleanly exiting the bot. It can be as simple
             as supplying <code>sys.exit</code>, though this will usually not be a clean exit. The
             <code>logout</code> parameter may be a coroutine function.</li>
<li><code>formatter</code> - A custom <code>Formatter</code> object for formatting things into platform-specific
                outputs. You can use one of k3's built-in formatters, or you can make one
                of your own. Formatters should be subclassed from
                <code>k3.formatters.BaseFormatter</code>.</li>
<li><code>config_file</code> - An <code>str</code> representing the configuration file of the bot. Defaults to
                  <code>config.json</code>. This doesn't really have to be used, but it's there for
                  convenience reasons.</li>
</ul>
<p>Instance variables not in the constructor:</p>
<ul>
<li><code>key</code> - An <code>str</code> key for the bot owner. Use this for platform-agnostic owner-only
          commands. Commands marked as owner-only will require the key to be supplied as
          the last command argument. Because the key obviously becomes public as soon as
          it's posted to a chat, it changes upon every use.</li>
<li><code>session</code> - An <code>aiohttp.ClientSession</code> that the bot can use to make HTTP requests.
              This is useful for commands that perform API hooks. If <code>aiohttp</code> is not
              available, this is just <code>None</code>.</li>
<li><code>config</code> - A <code>dict</code> containing key-value pairs meant for bot configuration. This doesn't
             really have to be used, but it's there for convenience reasons.</li>
</ul>
<p>Example usage:</p>
<pre><code>import discord

from k3 import commands

client = discord.Client()
bot = commands.Bot(loop=client.loop, prefix="&gt;&gt;", name="MyBot", logout=client.logout)
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Bot.__init__', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Bot.__init__" class="source">
    <pre><code>def __init__(self, *, loop: asyncio.AbstractEventLoop, prefix: str, name: str="k3",
             description: str="A bot made using the k3 command handler.", logout=None,
             formatter=None, config_file: str="config.json"):
    """This object respresents a command-based bot; i.e. it can process and handle commands.
    Commands are represented by `Command` objects.
    To use this, instantiate it and then call `Bot.process(text)` whenever a message event
    occurs. Some examples are provided in the repository.
    * `loop` - An `asyncio.AbstractEventLoop` to pass to the bot.
    * `prefix` - An `str` that the bot uses to identify whether a command is being
                 requested by someone. All attempted command invocations must start with
                 the prefix.
    * `name` - An `str` representing the name of the bot. Defaults to `k3`.
    * `description` - An `str` representing the description of the bot. Defaults to `A bot made
                      using the k3 command handler.`
    * `logout` - An optional callable parameter that allows for an abstracted bot logout. This
                 allows you to supply a method for cleanly exiting the bot. It can be as simple
                 as supplying `sys.exit`, though this will usually not be a clean exit. The
                 `logout` parameter may be a coroutine function.
    * `formatter` - A custom `Formatter` object for formatting things into platform-specific
                    outputs. You can use one of k3's built-in formatters, or you can make one
                    of your own. Formatters should be subclassed from
                    `k3.formatters.BaseFormatter`.
    * `config_file` - An `str` representing the configuration file of the bot. Defaults to
                      `config.json`. This doesn't really have to be used, but it's there for
                      convenience reasons.
    Instance variables not in the constructor:
    * `key` - An `str` key for the bot owner. Use this for platform-agnostic owner-only
              commands. Commands marked as owner-only will require the key to be supplied as
              the last command argument. Because the key obviously becomes public as soon as
              it's posted to a chat, it changes upon every use.
    * `session` - An `aiohttp.ClientSession` that the bot can use to make HTTP requests.
                  This is useful for commands that perform API hooks. If `aiohttp` is not
                  available, this is just `None`.
    * `config` - A `dict` containing key-value pairs meant for bot configuration. This doesn't
                 really have to be used, but it's there for convenience reasons.
    Example usage:
        import discord
        from k3 import commands
        client = discord.Client()
        bot = commands.Bot(loop=client.loop, prefix=">>", name="MyBot", logout=client.logout)
    """
    super(Bot, self).__init__(name=name)
    self.loop = loop
    try:
        self.session = aiohttp.ClientSession(loop=self.loop)
    except NameError:
        self.session = None
    self.prefix = prefix
    self.description = description
    self._logout = logout
    if not formatter:
        self.formatter = k3.formatters.core.BaseFormatter()
    elif not isinstance(formatter, k3.formatters.core.BaseFormatter):
        raise TypeError(f"{formatter} is not a BaseFormatter.")
    else:
        self.formatter = formatter
    self.config = {}
    self.config_file = config_file
    self._task_key_regeneration = self.loop.create_task(self._regenerate_key_auto())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Bot.add_command">
    <p>def <span class="ident">add_command</span>(</p><p>self, command)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a <code>Command</code> object to the group.</p>
<p>Normally, you do not call this by itself; instead, you use the <code>CommandGroupMixin.command</code>
decorator. Or you may call <code>Bot.add_module()</code> on a module that contains a series of commands
created using the <code>k3.command</code> decorator.</p>
<ul>
<li><code>command</code> - A <code>Command</code> object to be added.</li>
<li><code>skip_duplicate</code> - A <code>bool</code>. If <code>True</code>, the function returns immediately if the command
                     is found to already exist. Otherwise, it raises a <code>CommandExists</code>
                     exception. Defaults to <code>False</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Bot.add_command', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Bot.add_command" class="source">
    <pre><code>def add_command(self, command, *, skip_duplicate=False):
    """Add a `Command` object to the group.
    Normally, you do not call this by itself; instead, you use the `CommandGroupMixin.command`
    decorator. Or you may call `Bot.add_module()` on a module that contains a series of commands
    created using the `k3.command` decorator.
    * `command` - A `Command` object to be added.
    * `skip_duplicate` - A `bool`. If `True`, the function returns immediately if the command
                         is found to already exist. Otherwise, it raises a `CommandExists`
                         exception. Defaults to `False`.
    """
    if command.name in self.all_commands.keys() and skip_duplicate:
        return
    elif command.name in self.all_commands.keys():
        raise CommandExists(f"{command.name} is a command that already exists.")
    command.parent = self  # Set the command's bot instance
    self.commands[command.name] = command
    self.all_commands[command.name] = command
    for alias in command.aliases:
        self.all_commands[alias] = command
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Bot.add_module">
    <p>def <span class="ident">add_module</span>(</p><p>self, name)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a Python module to the bot, by name.</p>
<p>The bot will check said module for instances of <code>Command</code> and add all of them to itself.</p>
<ul>
<li><code>name</code> - An <code>str</code> representing the name of the module to import.</li>
<li><code>skip_duplicate_commands</code> - A <code>bool</code>. If <code>True</code>, the function will skip command names
                              that already exist. Otherwise, it raises a <code>CommandExists</code>
                              exception. Defaults to <code>False</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Bot.add_module', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Bot.add_module" class="source">
    <pre><code>def add_module(self, name: str, *, skip_duplicate_commands: bool=False):
    """Add a Python module to the bot, by name.
    The bot will check said module for instances of `Command` and add all of them to itself.
    * `name` - An `str` representing the name of the module to import.
    * `skip_duplicate_commands` - A `bool`. If `True`, the function will skip command names
                                  that already exist. Otherwise, it raises a `CommandExists`
                                  exception. Defaults to `False`.
    """
    # If the module is already in memory, we reload it instead.
    if name in sys.modules.keys():
        importlib.reload(sys.modules[name])
        module = sys.modules[name]
    else:
        module = importlib.import_module(name)
    for command in dir(module):
        command = getattr(module, command)
        if isinstance(command, Command) and not command.parent:
            self.add_command(command, skip_duplicate=skip_duplicate_commands)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Bot.command">
    <p>def <span class="ident">command</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>This is a shortcut decorator that directly adds a subcommand.</p>
<p>Refer to the <code>k3.command</code> decorator for more details, as it is functionally similar.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Bot.command', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Bot.command" class="source">
    <pre><code>def command(self, *, name: str=None, aliases: List[str]=[], help: str=None,
            owner_only: bool=False):
    """This is a shortcut decorator that directly adds a subcommand.
    Refer to the `k3.command` decorator for more details, as it is functionally similar.
    """
    def decorator(coro):
        new_command = Command(coro, name=name, aliases=aliases, help=help,
                              owner_only=owner_only)
        self.add_command(new_command)
        return new_command
    return decorator
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Bot.invoke">
    <p>def <span class="ident">invoke</span>(</p><p>self, message)</p>
    </div>
    

    
  
    <div class="desc"><p>This is a dummy <code>invoke</code> method, to be reimplemented in children classes.</p>
<p>It is called to invoke the <code>CommandGroupMixin</code>, but this is a mixin class and thus does
not have anything to invoke, really.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Bot.invoke', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Bot.invoke" class="source">
    <pre><code>async def invoke(self, message: str, *, is_owner: bool=False, callback_send,
                 character_limit: int=2000):
    """This is a dummy `invoke` method, to be reimplemented in children classes.
    It is called to invoke the `CommandGroupMixin`, but this is a mixin class and thus does
    not have anything to invoke, really.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Bot.load_config">
    <p>def <span class="ident">load_config</span>(</p><p>self, filename=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Load config from a JSON file.</p>
<ul>
<li><code>filename</code> - The filename of the JSON file to be loaded. If not specified, the bot will
               default to <code>Bot.config_file</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Bot.load_config', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Bot.load_config" class="source">
    <pre><code>def load_config(self, filename: str=None):
    """Load config from a JSON file.
    * `filename` - The filename of the JSON file to be loaded. If not specified, the bot will
                   default to `Bot.config_file`.
    """
    if not filename:
        filename = self.config_file
    with open(filename) as file_object:
        config = json.load(file_object)
    if isinstance(config, dict):
        for key, value in config.items():
            self.config[key] = value
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Bot.logout">
    <p>def <span class="ident">logout</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>An abstracted logout method. This is a coroutine.</p>
<p>You must specify the logout function in the <code>Bot</code> constructor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Bot.logout', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Bot.logout" class="source">
    <pre><code>async def logout(self):
    """An abstracted logout method. This is a coroutine.
    You must specify the logout function in the `Bot` constructor.
    """
    self.session.close()
    self._task_key_regeneration.cancel()
    if asyncio.iscoroutinefunction(self._logout):
        await self._logout()
    elif callable(self._logout):
        self._logout()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Bot.process">
    <p>def <span class="ident">process</span>(</p><p>self, message)</p>
    </div>
    

    
  
    <div class="desc"><p>Reimplemented <code>process</code> to check against the bot's prefix. Refer to
<code>CommandGroupMixin.process</code> for more details.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Bot.process', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Bot.process" class="source">
    <pre><code>async def process(self, message: str, *, callback_send, is_owner: bool=False,
                  character_limit: int=2000):
    """Reimplemented `process` to check against the bot's prefix. Refer to
    `CommandGroupMixin.process` for more details."""
    await super(Bot, self).process(message, callback_send=callback_send, is_owner=is_owner,
                                   character_limit=character_limit, prefixes=[self.prefix])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Bot.regenerate_key">
    <p>def <span class="ident">regenerate_key</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Generate a new key for the bot. Random alphanumeric string, 64 characters long.</p>
<p>This is called every 30 minutes, and also whenever an owner-only command is invoked unless
an override is requested.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Bot.regenerate_key', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Bot.regenerate_key" class="source">
    <pre><code>def regenerate_key(self):
    """Generate a new key for the bot. Random alphanumeric string, 64 characters long.
    This is called every 30 minutes, and also whenever an owner-only command is invoked unless
    an override is requested.
    """
    self.key = k3.keygen.generate_key()
    logger.info("Bot key is now {self.key}")
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Bot.remove_command">
    <p>def <span class="ident">remove_command</span>(</p><p>self, name)</p>
    </div>
    

    
  
    <div class="desc"><p>Remove a <code>Command</code> object from the group, by name.</p>
<ul>
<li><code>name</code> - An <code>str</code> referring to the name of the command to remove.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Bot.remove_command', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Bot.remove_command" class="source">
    <pre><code>def remove_command(self, name):
    """Remove a `Command` object from the group, by name.
    * `name` - An `str` referring to the name of the command to remove.
    """
    aliases = self.commands[name].aliases
    self.commands[name].parent = None
    del self.commands[name]
    del self.all_commands[name]
    for alias in aliases:
        del self.all_commands[alias]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Bot.remove_module">
    <p>def <span class="ident">remove_module</span>(</p><p>self, name)</p>
    </div>
    

    
  
    <div class="desc"><p>Remove a Python module to the bot, by name.</p>
<p>When this is called, the bot will remove all <code>Command</code> objects that belong to the module
in question. It does not unload the module from memory, as Python doesn't support this.
This isn't considered a serious issue, since the hit to memory usage shouldn't be
significant.</p>
<ul>
<li><code>name</code> - An <code>str</code> representing the name of the module to remove.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Bot.remove_module', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Bot.remove_module" class="source">
    <pre><code>def remove_module(self, name):
    """Remove a Python module to the bot, by name.
    When this is called, the bot will remove all `Command` objects that belong to the module
    in question. It does not unload the module from memory, as Python doesn't support this.
    This isn't considered a serious issue, since the hit to memory usage shouldn't be
    significant.
    * `name` - An `str` representing the name of the module to remove.
    """
    for command_name, command in tuple(self.commands.items()):
        if command.coro.__module__ == name:
            self.remove_command(command_name)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Bot.save_config">
    <p>def <span class="ident">save_config</span>(</p><p>self, filename=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Save config to a JSON file.</p>
<ul>
<li><code>filename</code> - The filename of the JSON file to be saved to. If not specified, the bot will
               default to <code>Bot.config_file</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Bot.save_config', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Bot.save_config" class="source">
    <pre><code>def save_config(self, filename: str=None):
    """Save config to a JSON file.
    * `filename` - The filename of the JSON file to be saved to. If not specified, the bot will
                   default to `Bot.config_file`.
    """
    if not filename:
        filename = self.config_file
    with open(filename, "w") as file_object:
        json.dump(self.config, file_object)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="k3.commands.Bot.config" class="name">var <span class="ident">config</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.Bot.config_file" class="name">var <span class="ident">config_file</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.Bot.description" class="name">var <span class="ident">description</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.Bot.loop" class="name">var <span class="ident">loop</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.Bot.prefix" class="name">var <span class="ident">prefix</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.Bot.top_level" class="name">var <span class="ident">top_level</span></p>
            

            
  
    <div class="desc"><p>Returns the top-level container for this object. Usually a commands.Bot().</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="k3.commands.Command" class="name">class <span class="ident">Command</span></p>
      
  
    <div class="desc"><p>This class contains partial command handling facilities, as well as command grouping
functionality. Generally, you do not use this by itself.</p>
<p>Both <code>Bot</code> and <code>Command</code> inherit from this class.</p>
<ul>
<li><code>commands</code> - A <code>dict</code> containing all of the bot's commands.</li>
<li><code>all_commands</code> - A <code>dict</code> containing all of the bot's commands, counting aliases.</li>
<li><code>name</code> - An <code>str</code> representing the name of the <code>CommandGroupMixin</code>. Children classes
           should reimplement <code>__init__</code> to set it as desired. <code>name</code> is used in <code>process</code>
           to detect command invocations, where a matching <code>name</code> will trigger the
           corresponding command.</li>
<li><code>aliases</code> - A <code>list</code> of <code>str</code> representing alternates to <code>name</code> for command invocations.</li>
<li><code>parent</code> - The parent object of the mixin; the command or bot that it has been added to.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Command', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Command" class="source">
    <pre><code>class Command(CommandGroupMixin):

    def __init__(self, coro, *, name: str=None, aliases: List[str]=[], help: str=None,
                 owner_only=False):
        """This object represents a command that a bot can use.

        Normally, you do not construct this directly. Use the decorator syntax instead.

        * `coro` - A coroutine function that the command uses upon calling `invoke()`.
                   Should have an `*args` to catch any extra arguments.
        * `name` - An `str` representing the name for the command. If unspecified, it's set to
                   `coro.__name__`.
        * `aliases` - A `list` of `str` representing aliases for the command; that is, alternative
                      names you can invoke the command under.
        * `help` - An `str` representing the command's help text. It can alternatively be read from
                   the coroutine's docstring, which makes code easier to read.
        * `owner_only` - A `bool`. Determines whether the command is meant for the bot owner only.
                         If `True`, the command will require the bot's temporary key as the final
                         command argument, and will fail to run unless `is_owner` is overridden in
                         the call to the `invoke()` method. Defaults to `False`.

        Instance variables not in the constructor:

        * `bot` - The `Bot` instance that the command is assigned to.
        * `signature` - An `inspect.Signature` reflecting the command signature.
        """

        name = name or coro.__name__
        super(Command, self).__init__(name=name, aliases=aliases)

        self.help = help or inspect.getdoc(coro)

        if not asyncio.iscoroutinefunction(coro):
            raise NotCoroutine(f"{coro.__name__} is not a coroutine function.")
        self.coro = coro
        self.signature = inspect.signature(self.coro)

        self.owner_only = owner_only

        # These are used internally for cooldowns.
        self._interval_start = 0  # This tracks the start of an interval.
        self._times_invoked = 0  # This tracks the number of times the command is used.
        self._limit = 0  # Limit of uses per interval
        self._interval = 0  # Interval in seconds

    def set_cooldown(self, limit: int, interval: float=1):
        """This sets the cooldown for the command.

        Normally, you do not call this directly; use the decorator syntax instead.

        * `limit` - An `int` representing the limit of uses per interval before the cooldown kicks.
        * `interval` - A `float` representing, in seconds, the interval before the cooldown resets.
                       Defaults to `1`.
        """
        self._limit = limit
        self._interval = interval

    def _update_cooldown(self):
        if self._limit > 1:
            invoke_time = time.time()
            if invoke_time - self._interval_start >= self._interval:
                self._times_invoked = 1
                self._interval_start = invoke_time
            elif self._times_invoked >= self._limit:
                raise OnCooldown("Command on cooldown.")
            else:
                self._times_invoked += 1

    async def invoke(self, message: str, *, is_owner: bool=False, callback_send,
                     character_limit: int=2000):
        """Calling this will invoke the command, provided a message string.

        Normally, you do not call this by itself; instead run `Bot.process()`.

        * `message` - An `str` to pass the command for processing.
        * `is_owner` - A `bool` that overrides the owner checking. Use this if you have some other
                       means of checking for the owner.
        * `callback_send` - A coroutine that k3 will use to send messages. This is library-
                            dependent, and you may have to define a custom coroutine depending on
                            the exact format of your library's methods.
        * `character_limit` - An `int` representing the number of allowed characters in a given
                              message.
        """
        # Cooldown
        self._update_cooldown()

        arguments = parse_arguments(message)
        invoked_with = arguments.pop(0)

        # Override.
        if is_owner:
            pass
        # Check arguments against the bot's key if owner_only.
        # We assume that top_level is a Bot in this case.
        elif self.owner_only and (not arguments or arguments[-1] != self.top_level.key):
            raise NotBotOwner("You don't own this bot.")
        elif self.owner_only:
            arguments.pop(-1)
            self.top_level.regenerate_key()

        ctx = Context(callback_send=callback_send, bot=self.top_level, command=self,
                      character_limit=character_limit, invoked_with=invoked_with)
        converted_arguments = convert_arguments(1, self.signature, *arguments)
        response = await self.coro(ctx, *converted_arguments)

        return response
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#k3.commands.Command">Command</a></li>
          <li><a href="#k3.commands.CommandGroupMixin">CommandGroupMixin</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="k3.commands.Command.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, coro)</p>
    </div>
    

    
  
    <div class="desc"><p>This object represents a command that a bot can use.</p>
<p>Normally, you do not construct this directly. Use the decorator syntax instead.</p>
<ul>
<li><code>coro</code> - A coroutine function that the command uses upon calling <code>invoke()</code>.
           Should have an <code>*args</code> to catch any extra arguments.</li>
<li><code>name</code> - An <code>str</code> representing the name for the command. If unspecified, it's set to
           <code>coro.__name__</code>.</li>
<li><code>aliases</code> - A <code>list</code> of <code>str</code> representing aliases for the command; that is, alternative
              names you can invoke the command under.</li>
<li><code>help</code> - An <code>str</code> representing the command's help text. It can alternatively be read from
           the coroutine's docstring, which makes code easier to read.</li>
<li><code>owner_only</code> - A <code>bool</code>. Determines whether the command is meant for the bot owner only.
                 If <code>True</code>, the command will require the bot's temporary key as the final
                 command argument, and will fail to run unless <code>is_owner</code> is overridden in
                 the call to the <code>invoke()</code> method. Defaults to <code>False</code>.</li>
</ul>
<p>Instance variables not in the constructor:</p>
<ul>
<li><code>bot</code> - The <code>Bot</code> instance that the command is assigned to.</li>
<li><code>signature</code> - An <code>inspect.Signature</code> reflecting the command signature.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Command.__init__', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Command.__init__" class="source">
    <pre><code>def __init__(self, coro, *, name: str=None, aliases: List[str]=[], help: str=None,
             owner_only=False):
    """This object represents a command that a bot can use.
    Normally, you do not construct this directly. Use the decorator syntax instead.
    * `coro` - A coroutine function that the command uses upon calling `invoke()`.
               Should have an `*args` to catch any extra arguments.
    * `name` - An `str` representing the name for the command. If unspecified, it's set to
               `coro.__name__`.
    * `aliases` - A `list` of `str` representing aliases for the command; that is, alternative
                  names you can invoke the command under.
    * `help` - An `str` representing the command's help text. It can alternatively be read from
               the coroutine's docstring, which makes code easier to read.
    * `owner_only` - A `bool`. Determines whether the command is meant for the bot owner only.
                     If `True`, the command will require the bot's temporary key as the final
                     command argument, and will fail to run unless `is_owner` is overridden in
                     the call to the `invoke()` method. Defaults to `False`.
    Instance variables not in the constructor:
    * `bot` - The `Bot` instance that the command is assigned to.
    * `signature` - An `inspect.Signature` reflecting the command signature.
    """
    name = name or coro.__name__
    super(Command, self).__init__(name=name, aliases=aliases)
    self.help = help or inspect.getdoc(coro)
    if not asyncio.iscoroutinefunction(coro):
        raise NotCoroutine(f"{coro.__name__} is not a coroutine function.")
    self.coro = coro
    self.signature = inspect.signature(self.coro)
    self.owner_only = owner_only
    # These are used internally for cooldowns.
    self._interval_start = 0  # This tracks the start of an interval.
    self._times_invoked = 0  # This tracks the number of times the command is used.
    self._limit = 0  # Limit of uses per interval
    self._interval = 0  # Interval in seconds
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Command.add_command">
    <p>def <span class="ident">add_command</span>(</p><p>self, command)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a <code>Command</code> object to the group.</p>
<p>Normally, you do not call this by itself; instead, you use the <code>CommandGroupMixin.command</code>
decorator. Or you may call <code>Bot.add_module()</code> on a module that contains a series of commands
created using the <code>k3.command</code> decorator.</p>
<ul>
<li><code>command</code> - A <code>Command</code> object to be added.</li>
<li><code>skip_duplicate</code> - A <code>bool</code>. If <code>True</code>, the function returns immediately if the command
                     is found to already exist. Otherwise, it raises a <code>CommandExists</code>
                     exception. Defaults to <code>False</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Command.add_command', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Command.add_command" class="source">
    <pre><code>def add_command(self, command, *, skip_duplicate=False):
    """Add a `Command` object to the group.
    Normally, you do not call this by itself; instead, you use the `CommandGroupMixin.command`
    decorator. Or you may call `Bot.add_module()` on a module that contains a series of commands
    created using the `k3.command` decorator.
    * `command` - A `Command` object to be added.
    * `skip_duplicate` - A `bool`. If `True`, the function returns immediately if the command
                         is found to already exist. Otherwise, it raises a `CommandExists`
                         exception. Defaults to `False`.
    """
    if command.name in self.all_commands.keys() and skip_duplicate:
        return
    elif command.name in self.all_commands.keys():
        raise CommandExists(f"{command.name} is a command that already exists.")
    command.parent = self  # Set the command's bot instance
    self.commands[command.name] = command
    self.all_commands[command.name] = command
    for alias in command.aliases:
        self.all_commands[alias] = command
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Command.command">
    <p>def <span class="ident">command</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>This is a shortcut decorator that directly adds a subcommand.</p>
<p>Refer to the <code>k3.command</code> decorator for more details, as it is functionally similar.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Command.command', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Command.command" class="source">
    <pre><code>def command(self, *, name: str=None, aliases: List[str]=[], help: str=None,
            owner_only: bool=False):
    """This is a shortcut decorator that directly adds a subcommand.
    Refer to the `k3.command` decorator for more details, as it is functionally similar.
    """
    def decorator(coro):
        new_command = Command(coro, name=name, aliases=aliases, help=help,
                              owner_only=owner_only)
        self.add_command(new_command)
        return new_command
    return decorator
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Command.invoke">
    <p>def <span class="ident">invoke</span>(</p><p>self, message)</p>
    </div>
    

    
  
    <div class="desc"><p>Calling this will invoke the command, provided a message string.</p>
<p>Normally, you do not call this by itself; instead run <code>Bot.process()</code>.</p>
<ul>
<li><code>message</code> - An <code>str</code> to pass the command for processing.</li>
<li><code>is_owner</code> - A <code>bool</code> that overrides the owner checking. Use this if you have some other
               means of checking for the owner.</li>
<li><code>callback_send</code> - A coroutine that k3 will use to send messages. This is library-
                    dependent, and you may have to define a custom coroutine depending on
                    the exact format of your library's methods.</li>
<li><code>character_limit</code> - An <code>int</code> representing the number of allowed characters in a given
                      message.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Command.invoke', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Command.invoke" class="source">
    <pre><code>async def invoke(self, message: str, *, is_owner: bool=False, callback_send,
                 character_limit: int=2000):
    """Calling this will invoke the command, provided a message string.
    Normally, you do not call this by itself; instead run `Bot.process()`.
    * `message` - An `str` to pass the command for processing.
    * `is_owner` - A `bool` that overrides the owner checking. Use this if you have some other
                   means of checking for the owner.
    * `callback_send` - A coroutine that k3 will use to send messages. This is library-
                        dependent, and you may have to define a custom coroutine depending on
                        the exact format of your library's methods.
    * `character_limit` - An `int` representing the number of allowed characters in a given
                          message.
    """
    # Cooldown
    self._update_cooldown()
    arguments = parse_arguments(message)
    invoked_with = arguments.pop(0)
    # Override.
    if is_owner:
        pass
    # Check arguments against the bot's key if owner_only.
    # We assume that top_level is a Bot in this case.
    elif self.owner_only and (not arguments or arguments[-1] != self.top_level.key):
        raise NotBotOwner("You don't own this bot.")
    elif self.owner_only:
        arguments.pop(-1)
        self.top_level.regenerate_key()
    ctx = Context(callback_send=callback_send, bot=self.top_level, command=self,
                  character_limit=character_limit, invoked_with=invoked_with)
    converted_arguments = convert_arguments(1, self.signature, *arguments)
    response = await self.coro(ctx, *converted_arguments)
    return response
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Command.process">
    <p>def <span class="ident">process</span>(</p><p>self, message)</p>
    </div>
    

    
  
    <div class="desc"><p>Process the given message. This is a coroutine.</p>
<ul>
<li><code>message</code> - A message <code>str</code> for the bot to process.</li>
<li><code>is_owner</code> - A <code>bool</code> used to force an owner check override if you want an alternative
               handler instead of k3's clunky key system. This is useful if the library you
               use has some automated means of distinguishing the bot owner. For example,
               discord.py offers owner information via <code>discord.Client.application_info()</code>,
               so you can use that to check if the message sender is the owner, and then
               pass the result on to the k3 handler.</li>
<li><code>callback_send</code> - A coroutine that k3 will use to send messages. This is library-
                    dependent, and you may have to define a custom coroutine depending on
                    the exact format of your library's methods.</li>
<li><code>character_limit</code> - An <code>int</code> representing the number of allowed characters in a given
                      message.</li>
<li><code>prefixes</code> - A <code>list</code> of <code>str</code> to look out for in the process of invoking commands.
               If a message starts with one of the <code>str</code> in the <code>list</code>, then an
               invocation will be attempted. Normally, you don't override this.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Command.process', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Command.process" class="source">
    <pre><code>async def process(self, message: str, *, callback_send, is_owner: bool=False,
                  character_limit: int=2000, prefixes: List[str]=[]):
    """Process the given message. This is a coroutine.
    * `message` - A message `str` for the bot to process.
    * `is_owner` - A `bool` used to force an owner check override if you want an alternative
                   handler instead of k3's clunky key system. This is useful if the library you
                   use has some automated means of distinguishing the bot owner. For example,
                   discord.py offers owner information via `discord.Client.application_info()`,
                   so you can use that to check if the message sender is the owner, and then
                   pass the result on to the k3 handler.
    * `callback_send` - A coroutine that k3 will use to send messages. This is library-
                        dependent, and you may have to define a custom coroutine depending on
                        the exact format of your library's methods.
    * `character_limit` - An `int` representing the number of allowed characters in a given
                          message.
    * `prefixes` - A `list` of `str` to look out for in the process of invoking commands.
                   If a message starts with one of the `str` in the `list`, then an
                   invocation will be attempted. Normally, you don't override this.
    """
    if not prefixes:
        prefixes = [self.name] + self.aliases
    for prefix in prefixes:
        if message.startswith(prefix):
            noprefix_message = message[len(prefix):].strip()
            arguments = noprefix_message.split(" ")
            if arguments and arguments[0] in self.all_commands.keys():
                await self.all_commands[arguments[0]].process(noprefix_message,
                                                              is_owner=is_owner,
                                                              callback_send=callback_send,
                                                              character_limit=character_limit)
            else:
                await self.invoke(message, is_owner=is_owner, callback_send=callback_send,
                                  character_limit=character_limit)
            break
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Command.remove_command">
    <p>def <span class="ident">remove_command</span>(</p><p>self, name)</p>
    </div>
    

    
  
    <div class="desc"><p>Remove a <code>Command</code> object from the group, by name.</p>
<ul>
<li><code>name</code> - An <code>str</code> referring to the name of the command to remove.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Command.remove_command', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Command.remove_command" class="source">
    <pre><code>def remove_command(self, name):
    """Remove a `Command` object from the group, by name.
    * `name` - An `str` referring to the name of the command to remove.
    """
    aliases = self.commands[name].aliases
    self.commands[name].parent = None
    del self.commands[name]
    del self.all_commands[name]
    for alias in aliases:
        del self.all_commands[alias]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Command.set_cooldown">
    <p>def <span class="ident">set_cooldown</span>(</p><p>self, limit, interval=1)</p>
    </div>
    

    
  
    <div class="desc"><p>This sets the cooldown for the command.</p>
<p>Normally, you do not call this directly; use the decorator syntax instead.</p>
<ul>
<li><code>limit</code> - An <code>int</code> representing the limit of uses per interval before the cooldown kicks.</li>
<li><code>interval</code> - A <code>float</code> representing, in seconds, the interval before the cooldown resets.
               Defaults to <code>1</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Command.set_cooldown', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Command.set_cooldown" class="source">
    <pre><code>def set_cooldown(self, limit: int, interval: float=1):
    """This sets the cooldown for the command.
    Normally, you do not call this directly; use the decorator syntax instead.
    * `limit` - An `int` representing the limit of uses per interval before the cooldown kicks.
    * `interval` - A `float` representing, in seconds, the interval before the cooldown resets.
                   Defaults to `1`.
    """
    self._limit = limit
    self._interval = interval
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="k3.commands.Command.coro" class="name">var <span class="ident">coro</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.Command.help" class="name">var <span class="ident">help</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.Command.owner_only" class="name">var <span class="ident">owner_only</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.Command.signature" class="name">var <span class="ident">signature</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.Command.top_level" class="name">var <span class="ident">top_level</span></p>
            

            
  
    <div class="desc"><p>Returns the top-level container for this object. Usually a commands.Bot().</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="k3.commands.CommandExists" class="name">class <span class="ident">CommandExists</span></p>
      
  
    <div class="desc"><p>Raised if a command registration attempt is made, but the name already exists in the bot.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.CommandExists', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.CommandExists" class="source">
    <pre><code>class CommandExists(Exception):
    """Raised if a command registration attempt is made, but the name already exists in the bot."""
    pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#k3.commands.CommandExists">CommandExists</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="k3.commands.CommandExists.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="k3.commands.CommandGroupMixin" class="name">class <span class="ident">CommandGroupMixin</span></p>
      
  
    <div class="desc"><p>This class contains partial command handling facilities, as well as command grouping
functionality. Generally, you do not use this by itself.</p>
<p>Both <code>Bot</code> and <code>Command</code> inherit from this class.</p>
<ul>
<li><code>commands</code> - A <code>dict</code> containing all of the bot's commands.</li>
<li><code>all_commands</code> - A <code>dict</code> containing all of the bot's commands, counting aliases.</li>
<li><code>name</code> - An <code>str</code> representing the name of the <code>CommandGroupMixin</code>. Children classes
           should reimplement <code>__init__</code> to set it as desired. <code>name</code> is used in <code>process</code>
           to detect command invocations, where a matching <code>name</code> will trigger the
           corresponding command.</li>
<li><code>aliases</code> - A <code>list</code> of <code>str</code> representing alternates to <code>name</code> for command invocations.</li>
<li><code>parent</code> - The parent object of the mixin; the command or bot that it has been added to.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.CommandGroupMixin', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.CommandGroupMixin" class="source">
    <pre><code>class CommandGroupMixin:
    """This class contains partial command handling facilities, as well as command grouping
    functionality. Generally, you do not use this by itself.

    Both `Bot` and `Command` inherit from this class.

    * `commands` - A `dict` containing all of the bot's commands.
    * `all_commands` - A `dict` containing all of the bot's commands, counting aliases.
    * `name` - An `str` representing the name of the `CommandGroupMixin`. Children classes
               should reimplement `__init__` to set it as desired. `name` is used in `process`
               to detect command invocations, where a matching `name` will trigger the
               corresponding command.
    * `aliases` - A `list` of `str` representing alternates to `name` for command invocations.
    * `parent` - The parent object of the mixin; the command or bot that it has been added to.
    """

    def __init__(self, *, name: str=None, aliases: List[str]=[]):
        self.commands = {}
        self.all_commands = {}
        self.name = name or self.__name__
        self.aliases = []
        self.parent = None

    def add_command(self, command, *, skip_duplicate=False):
        """Add a `Command` object to the group.

        Normally, you do not call this by itself; instead, you use the `CommandGroupMixin.command`
        decorator. Or you may call `Bot.add_module()` on a module that contains a series of commands
        created using the `k3.command` decorator.

        * `command` - A `Command` object to be added.
        * `skip_duplicate` - A `bool`. If `True`, the function returns immediately if the command
                             is found to already exist. Otherwise, it raises a `CommandExists`
                             exception. Defaults to `False`.
        """
        if command.name in self.all_commands.keys() and skip_duplicate:
            return
        elif command.name in self.all_commands.keys():
            raise CommandExists(f"{command.name} is a command that already exists.")
        command.parent = self  # Set the command's bot instance
        self.commands[command.name] = command
        self.all_commands[command.name] = command
        for alias in command.aliases:
            self.all_commands[alias] = command

    def remove_command(self, name):
        """Remove a `Command` object from the group, by name.

        * `name` - An `str` referring to the name of the command to remove.
        """
        aliases = self.commands[name].aliases
        self.commands[name].parent = None
        del self.commands[name]
        del self.all_commands[name]
        for alias in aliases:
            del self.all_commands[alias]

    async def process(self, message: str, *, callback_send, is_owner: bool=False,
                      character_limit: int=2000, prefixes: List[str]=[]):
        """Process the given message. This is a coroutine.

        * `message` - A message `str` for the bot to process.
        * `is_owner` - A `bool` used to force an owner check override if you want an alternative
                       handler instead of k3's clunky key system. This is useful if the library you
                       use has some automated means of distinguishing the bot owner. For example,
                       discord.py offers owner information via `discord.Client.application_info()`,
                       so you can use that to check if the message sender is the owner, and then
                       pass the result on to the k3 handler.
        * `callback_send` - A coroutine that k3 will use to send messages. This is library-
                            dependent, and you may have to define a custom coroutine depending on
                            the exact format of your library's methods.
        * `character_limit` - An `int` representing the number of allowed characters in a given
                              message.
        * `prefixes` - A `list` of `str` to look out for in the process of invoking commands.
                       If a message starts with one of the `str` in the `list`, then an
                       invocation will be attempted. Normally, you don't override this.
        """
        if not prefixes:
            prefixes = [self.name] + self.aliases

        for prefix in prefixes:
            if message.startswith(prefix):

                noprefix_message = message[len(prefix):].strip()
                arguments = noprefix_message.split(" ")

                if arguments and arguments[0] in self.all_commands.keys():
                    await self.all_commands[arguments[0]].process(noprefix_message,
                                                                  is_owner=is_owner,
                                                                  callback_send=callback_send,
                                                                  character_limit=character_limit)
                else:
                    await self.invoke(message, is_owner=is_owner, callback_send=callback_send,
                                      character_limit=character_limit)
                break

    async def invoke(self, message: str, *, is_owner: bool=False, callback_send,
                     character_limit: int=2000):
        """This is a dummy `invoke` method, to be reimplemented in children classes.

        It is called to invoke the `CommandGroupMixin`, but this is a mixin class and thus does
        not have anything to invoke, really.
        """
        pass

    def command(self, *, name: str=None, aliases: List[str]=[], help: str=None,
                owner_only: bool=False):
        """This is a shortcut decorator that directly adds a subcommand.

        Refer to the `k3.command` decorator for more details, as it is functionally similar.
        """

        def decorator(coro):
            new_command = Command(coro, name=name, aliases=aliases, help=help,
                                  owner_only=owner_only)
            self.add_command(new_command)
            return new_command

        return decorator

    @property
    def top_level(self):
        """Returns the top-level container for this object. Usually a commands.Bot()."""
        current_level = self
        while current_level.parent:
            current_level = current_level.parent
        return current_level
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#k3.commands.CommandGroupMixin">CommandGroupMixin</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="k3.commands.CommandGroupMixin.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.CommandGroupMixin.__init__', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.CommandGroupMixin.__init__" class="source">
    <pre><code>def __init__(self, *, name: str=None, aliases: List[str]=[]):
    self.commands = {}
    self.all_commands = {}
    self.name = name or self.__name__
    self.aliases = []
    self.parent = None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.CommandGroupMixin.add_command">
    <p>def <span class="ident">add_command</span>(</p><p>self, command)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a <code>Command</code> object to the group.</p>
<p>Normally, you do not call this by itself; instead, you use the <code>CommandGroupMixin.command</code>
decorator. Or you may call <code>Bot.add_module()</code> on a module that contains a series of commands
created using the <code>k3.command</code> decorator.</p>
<ul>
<li><code>command</code> - A <code>Command</code> object to be added.</li>
<li><code>skip_duplicate</code> - A <code>bool</code>. If <code>True</code>, the function returns immediately if the command
                     is found to already exist. Otherwise, it raises a <code>CommandExists</code>
                     exception. Defaults to <code>False</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.CommandGroupMixin.add_command', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.CommandGroupMixin.add_command" class="source">
    <pre><code>def add_command(self, command, *, skip_duplicate=False):
    """Add a `Command` object to the group.
    Normally, you do not call this by itself; instead, you use the `CommandGroupMixin.command`
    decorator. Or you may call `Bot.add_module()` on a module that contains a series of commands
    created using the `k3.command` decorator.
    * `command` - A `Command` object to be added.
    * `skip_duplicate` - A `bool`. If `True`, the function returns immediately if the command
                         is found to already exist. Otherwise, it raises a `CommandExists`
                         exception. Defaults to `False`.
    """
    if command.name in self.all_commands.keys() and skip_duplicate:
        return
    elif command.name in self.all_commands.keys():
        raise CommandExists(f"{command.name} is a command that already exists.")
    command.parent = self  # Set the command's bot instance
    self.commands[command.name] = command
    self.all_commands[command.name] = command
    for alias in command.aliases:
        self.all_commands[alias] = command
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.CommandGroupMixin.command">
    <p>def <span class="ident">command</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>This is a shortcut decorator that directly adds a subcommand.</p>
<p>Refer to the <code>k3.command</code> decorator for more details, as it is functionally similar.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.CommandGroupMixin.command', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.CommandGroupMixin.command" class="source">
    <pre><code>def command(self, *, name: str=None, aliases: List[str]=[], help: str=None,
            owner_only: bool=False):
    """This is a shortcut decorator that directly adds a subcommand.
    Refer to the `k3.command` decorator for more details, as it is functionally similar.
    """
    def decorator(coro):
        new_command = Command(coro, name=name, aliases=aliases, help=help,
                              owner_only=owner_only)
        self.add_command(new_command)
        return new_command
    return decorator
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.CommandGroupMixin.invoke">
    <p>def <span class="ident">invoke</span>(</p><p>self, message)</p>
    </div>
    

    
  
    <div class="desc"><p>This is a dummy <code>invoke</code> method, to be reimplemented in children classes.</p>
<p>It is called to invoke the <code>CommandGroupMixin</code>, but this is a mixin class and thus does
not have anything to invoke, really.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.CommandGroupMixin.invoke', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.CommandGroupMixin.invoke" class="source">
    <pre><code>async def invoke(self, message: str, *, is_owner: bool=False, callback_send,
                 character_limit: int=2000):
    """This is a dummy `invoke` method, to be reimplemented in children classes.
    It is called to invoke the `CommandGroupMixin`, but this is a mixin class and thus does
    not have anything to invoke, really.
    """
    pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.CommandGroupMixin.process">
    <p>def <span class="ident">process</span>(</p><p>self, message)</p>
    </div>
    

    
  
    <div class="desc"><p>Process the given message. This is a coroutine.</p>
<ul>
<li><code>message</code> - A message <code>str</code> for the bot to process.</li>
<li><code>is_owner</code> - A <code>bool</code> used to force an owner check override if you want an alternative
               handler instead of k3's clunky key system. This is useful if the library you
               use has some automated means of distinguishing the bot owner. For example,
               discord.py offers owner information via <code>discord.Client.application_info()</code>,
               so you can use that to check if the message sender is the owner, and then
               pass the result on to the k3 handler.</li>
<li><code>callback_send</code> - A coroutine that k3 will use to send messages. This is library-
                    dependent, and you may have to define a custom coroutine depending on
                    the exact format of your library's methods.</li>
<li><code>character_limit</code> - An <code>int</code> representing the number of allowed characters in a given
                      message.</li>
<li><code>prefixes</code> - A <code>list</code> of <code>str</code> to look out for in the process of invoking commands.
               If a message starts with one of the <code>str</code> in the <code>list</code>, then an
               invocation will be attempted. Normally, you don't override this.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.CommandGroupMixin.process', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.CommandGroupMixin.process" class="source">
    <pre><code>async def process(self, message: str, *, callback_send, is_owner: bool=False,
                  character_limit: int=2000, prefixes: List[str]=[]):
    """Process the given message. This is a coroutine.
    * `message` - A message `str` for the bot to process.
    * `is_owner` - A `bool` used to force an owner check override if you want an alternative
                   handler instead of k3's clunky key system. This is useful if the library you
                   use has some automated means of distinguishing the bot owner. For example,
                   discord.py offers owner information via `discord.Client.application_info()`,
                   so you can use that to check if the message sender is the owner, and then
                   pass the result on to the k3 handler.
    * `callback_send` - A coroutine that k3 will use to send messages. This is library-
                        dependent, and you may have to define a custom coroutine depending on
                        the exact format of your library's methods.
    * `character_limit` - An `int` representing the number of allowed characters in a given
                          message.
    * `prefixes` - A `list` of `str` to look out for in the process of invoking commands.
                   If a message starts with one of the `str` in the `list`, then an
                   invocation will be attempted. Normally, you don't override this.
    """
    if not prefixes:
        prefixes = [self.name] + self.aliases
    for prefix in prefixes:
        if message.startswith(prefix):
            noprefix_message = message[len(prefix):].strip()
            arguments = noprefix_message.split(" ")
            if arguments and arguments[0] in self.all_commands.keys():
                await self.all_commands[arguments[0]].process(noprefix_message,
                                                              is_owner=is_owner,
                                                              callback_send=callback_send,
                                                              character_limit=character_limit)
            else:
                await self.invoke(message, is_owner=is_owner, callback_send=callback_send,
                                  character_limit=character_limit)
            break
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.CommandGroupMixin.remove_command">
    <p>def <span class="ident">remove_command</span>(</p><p>self, name)</p>
    </div>
    

    
  
    <div class="desc"><p>Remove a <code>Command</code> object from the group, by name.</p>
<ul>
<li><code>name</code> - An <code>str</code> referring to the name of the command to remove.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.CommandGroupMixin.remove_command', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.CommandGroupMixin.remove_command" class="source">
    <pre><code>def remove_command(self, name):
    """Remove a `Command` object from the group, by name.
    * `name` - An `str` referring to the name of the command to remove.
    """
    aliases = self.commands[name].aliases
    self.commands[name].parent = None
    del self.commands[name]
    del self.all_commands[name]
    for alias in aliases:
        del self.all_commands[alias]
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="k3.commands.CommandGroupMixin.aliases" class="name">var <span class="ident">aliases</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.CommandGroupMixin.all_commands" class="name">var <span class="ident">all_commands</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.CommandGroupMixin.commands" class="name">var <span class="ident">commands</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.CommandGroupMixin.name" class="name">var <span class="ident">name</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.CommandGroupMixin.parent" class="name">var <span class="ident">parent</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.CommandGroupMixin.top_level" class="name">var <span class="ident">top_level</span></p>
            

            
  
    <div class="desc"><p>Returns the top-level container for this object. Usually a commands.Bot().</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="k3.commands.Context" class="name">class <span class="ident">Context</span></p>
      
  
    <div class="desc"><p>This object represents an abstracted context under which a <code>Command</code> is invoked.</p>
<p>You don't make these manually.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Context', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Context" class="source">
    <pre><code>class Context:
    """This object represents an abstracted context under which a `Command` is invoked.

    You don't make these manually.
    """

    def __init__(self, *, callback_send, character_limit: int=2000, command, bot,
                 invoked_with: str):
        """**Parameters**

        * `callback_send` - A coroutine for sending a message. This is entirely dependent on your
                            library. You may have to implement a custom coroutine, depending on
                            the format of your library's own method for sending messages.
        * `character_limit` - An `int` representing the maximum allowable characters per message.
                              The abstracted `send` method will automatically split messages that
                              are too long; if this behavior is undesirable, you should do a
                              manual truncation.
        * `command` - The `Command` object associated with the context.
        * `bot` - The `Bot` object associated with your bot.
        * `invoked_with` - `str` representing the command name associated with the context.
        * `formatter` or `f` - Shorthand for `ctx.bot.formatter`.
        """
        if not asyncio.iscoroutinefunction(callback_send):
            raise NotCoroutine(f"{callback_send.__name__} is not a coroutine function.")
        self._callback_send = callback_send
        self.bot = bot
        self.command = command
        self.character_limit = character_limit
        self.invoked_with = invoked_with

    @property
    def formatter(self):
        """Shorthand for `ctx.bot.formatter`."""
        return self.bot.formatter

    @property
    def f(self):
        """Shorthand for `ctx.bot.formatter`."""
        return self.bot.formatter

    async def send(self, message):
        """An abstracted method that sends a message to the desired location. This is a coroutine.

        You must specify the actual send method in the `Context` constructor.
        """
        message = str(message)
        cl = self.character_limit
        pages = [message[i:i+cl] for i in range(0, len(message), cl)]
        for page in pages:
            await self._callback_send(page)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#k3.commands.Context">Context</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="k3.commands.Context.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p><strong>Parameters</strong></p>
<ul>
<li><code>callback_send</code> - A coroutine for sending a message. This is entirely dependent on your
                    library. You may have to implement a custom coroutine, depending on
                    the format of your library's own method for sending messages.</li>
<li><code>character_limit</code> - An <code>int</code> representing the maximum allowable characters per message.
                      The abstracted <code>send</code> method will automatically split messages that
                      are too long; if this behavior is undesirable, you should do a
                      manual truncation.</li>
<li><code>command</code> - The <code>Command</code> object associated with the context.</li>
<li><code>bot</code> - The <code>Bot</code> object associated with your bot.</li>
<li><code>invoked_with</code> - <code>str</code> representing the command name associated with the context.</li>
<li><code>formatter</code> or <code>f</code> - Shorthand for <code>ctx.bot.formatter</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Context.__init__', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Context.__init__" class="source">
    <pre><code>def __init__(self, *, callback_send, character_limit: int=2000, command, bot,
             invoked_with: str):
    """**Parameters**
    * `callback_send` - A coroutine for sending a message. This is entirely dependent on your
                        library. You may have to implement a custom coroutine, depending on
                        the format of your library's own method for sending messages.
    * `character_limit` - An `int` representing the maximum allowable characters per message.
                          The abstracted `send` method will automatically split messages that
                          are too long; if this behavior is undesirable, you should do a
                          manual truncation.
    * `command` - The `Command` object associated with the context.
    * `bot` - The `Bot` object associated with your bot.
    * `invoked_with` - `str` representing the command name associated with the context.
    * `formatter` or `f` - Shorthand for `ctx.bot.formatter`.
    """
    if not asyncio.iscoroutinefunction(callback_send):
        raise NotCoroutine(f"{callback_send.__name__} is not a coroutine function.")
    self._callback_send = callback_send
    self.bot = bot
    self.command = command
    self.character_limit = character_limit
    self.invoked_with = invoked_with
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="k3.commands.Context.send">
    <p>def <span class="ident">send</span>(</p><p>self, message)</p>
    </div>
    

    
  
    <div class="desc"><p>An abstracted method that sends a message to the desired location. This is a coroutine.</p>
<p>You must specify the actual send method in the <code>Context</code> constructor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.Context.send', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.Context.send" class="source">
    <pre><code>async def send(self, message):
    """An abstracted method that sends a message to the desired location. This is a coroutine.
    You must specify the actual send method in the `Context` constructor.
    """
    message = str(message)
    cl = self.character_limit
    pages = [message[i:i+cl] for i in range(0, len(message), cl)]
    for page in pages:
        await self._callback_send(page)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="k3.commands.Context.bot" class="name">var <span class="ident">bot</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.Context.character_limit" class="name">var <span class="ident">character_limit</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.Context.command" class="name">var <span class="ident">command</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.Context.f" class="name">var <span class="ident">f</span></p>
            

            
  
    <div class="desc"><p>Shorthand for <code>ctx.bot.formatter</code>.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.Context.formatter" class="name">var <span class="ident">formatter</span></p>
            

            
  
    <div class="desc"><p>Shorthand for <code>ctx.bot.formatter</code>.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="k3.commands.Context.invoked_with" class="name">var <span class="ident">invoked_with</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="k3.commands.NotBotOwner" class="name">class <span class="ident">NotBotOwner</span></p>
      
  
    <div class="desc"><p>Raised if an owner-only command is invoked by someone who isn't the bot owner.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.NotBotOwner', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.NotBotOwner" class="source">
    <pre><code>class NotBotOwner(Exception):
    """Raised if an owner-only command is invoked by someone who isn't the bot owner."""
    pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#k3.commands.NotBotOwner">NotBotOwner</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="k3.commands.NotBotOwner.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="k3.commands.NotCoroutine" class="name">class <span class="ident">NotCoroutine</span></p>
      
  
    <div class="desc"><p>Raised if a command is passed a function that is not a coroutine.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.NotCoroutine', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.NotCoroutine" class="source">
    <pre><code>class NotCoroutine(Exception):
    """Raised if a command is passed a function that is not a coroutine."""
    pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#k3.commands.NotCoroutine">NotCoroutine</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="k3.commands.NotCoroutine.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="k3.commands.OnCooldown" class="name">class <span class="ident">OnCooldown</span></p>
      
  
    <div class="desc"><p>Raised if a command is invoked while on cooldown.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-k3.commands.OnCooldown', this);">Show source &equiv;</a></p>
  <div id="source-k3.commands.OnCooldown" class="source">
    <pre><code>class OnCooldown(Exception):
    """Raised if a command is invoked while on cooldown."""
    pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#k3.commands.OnCooldown">OnCooldown</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="k3.commands.OnCooldown.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
